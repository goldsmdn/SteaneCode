

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>circuits module &mdash; Steane Code 0.1 documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="test_circuits module" href="test_circuits.html" />
    <link rel="prev" title="Python modules" href="modules.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> Steane Code
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="documentation.html">Documentation</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">Python modules</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">circuits module</a></li>
<li class="toctree-l2"><a class="reference internal" href="test_circuits.html">test_circuits module</a></li>
<li class="toctree-l2"><a class="reference internal" href="helper_functions.html">helper_functions module</a></li>
</ul>
</li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Steane Code</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="modules.html">Python modules</a> &raquo;</li>
        
      <li>circuits module</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/circuits.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="module-circuits">
<span id="circuits-module"></span><h1>circuits module<a class="headerlink" href="#module-circuits" title="Permalink to this headline">¶</a></h1>
<p>Class to handle logical qubits for the Steane and Bacon Shor code</p>
<dl class="py class">
<dt class="sig sig-object py" id="circuits.BaconShorCodeLogicalQubit">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">circuits.</span></span><span class="sig-name descname"><span class="pre">BaconShorCodeLogicalQubit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ancilla_qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ancillas</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">blocks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logical_one</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logical_z</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_barrier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.BaconShorCodeLogicalQubit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">qiskit.circuit.quantumcircuit.QuantumCircuit</span></code></p>
<p>Generates the gates for one logical Qubits of the Bacon Shor code</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>int</em>) – Number of logical “data” qubits to be initialised.
Should be either 1 or 2 at present.
Only the case with 1 qubit has been fully tested.</p></li>
<li><p><strong>data_qubits</strong> (<em>int</em>) – Number of data qubits.  Usually nine.</p></li>
<li><p><strong>ancilla_qubits</strong> (<em>int</em>) – Number of ancilla qubits.  Usually two.</p></li>
<li><p><strong>ancilla</strong> (<em>int</em>) – Number of ancilla.  Usually two for X and Z.</p></li>
<li><p><strong>blocks</strong> (<em>int</em>) – Number of blocks</p></li>
<li><p><strong>logical_z</strong> (<em>bool</em>) – True if a logical z is set up.  Otherwise false</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="circuits.BaconShorCodeLogicalQubit.ancilla_dummy_gates">
<span class="sig-name descname"><span class="pre">ancilla_dummy_gates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.BaconShorCodeLogicalQubit.ancilla_dummy_gates" title="Permalink to this definition">¶</a></dt>
<dd><p>sets up a set of dummy ‘id’ gates against which noise is applied for each ancilla</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubit to measure.
Should be either 0 or 1 at present.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.BaconShorCodeLogicalQubit.define_data">
<span class="sig-name descname"><span class="pre">define_data</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#circuits.BaconShorCodeLogicalQubit.define_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines empty lists</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.BaconShorCodeLogicalQubit.define_registers">
<span class="sig-name descname"><span class="pre">define_registers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.BaconShorCodeLogicalQubit.define_registers" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up registers used based on number of logical qubits
and whether error checking is needed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>d</strong> (<em>int</em>) – Number of the logical “data” qubits to be initialised.
Should be either 0 or 1 at present.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The registers are stored in a list so that they can be
indexed to simplify subsequent code.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.BaconShorCodeLogicalQubit.encoding_ft">
<span class="sig-name descname"><span class="pre">encoding_ft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.BaconShorCodeLogicalQubit.encoding_ft" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds an encoding non fault tolerant gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubit to encode.
Should be either 0 or 1 at present.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.BaconShorCodeLogicalQubit.encoding_nft">
<span class="sig-name descname"><span class="pre">encoding_nft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.BaconShorCodeLogicalQubit.encoding_nft" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds an encoding non fault tolerant gate.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubit to encode.
Should be either 0 or 1 at present.</p></li>
<li><p><strong>logical_one</strong> (<em>Bool</em>) – If true set up the logical one.  Otherwise set up the logical zero.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.BaconShorCodeLogicalQubit.logical_measure">
<span class="sig-name descname"><span class="pre">logical_measure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.BaconShorCodeLogicalQubit.logical_measure" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to measure a logical qubit</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubit to measure.
Should be either 0 or 1 at present.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.BaconShorCodeLogicalQubit.reset_stabilizers">
<span class="sig-name descname"><span class="pre">reset_stabilizers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.BaconShorCodeLogicalQubit.reset_stabilizers" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to reset all ancilla</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubit to set up ancilla for.
Should be either 0 or 1 at present.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.BaconShorCodeLogicalQubit.x_stabilizers">
<span class="sig-name descname"><span class="pre">x_stabilizers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.BaconShorCodeLogicalQubit.x_stabilizers" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to set up x stabilizers or ancilla</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubit to set up ancilla for.
Should be either 0 or 1 at present.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.BaconShorCodeLogicalQubit.x_testing">
<span class="sig-name descname"><span class="pre">x_testing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_x_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.BaconShorCodeLogicalQubit.x_testing" title="Permalink to this definition">¶</a></dt>
<dd><p>Introduces one X error</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubit to test.
Should be either 0 or 1 at present.</p></li>
<li><p><strong>test_x_qubit</strong> (<em>int</em>) – Qubit on which X error is introduced</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.BaconShorCodeLogicalQubit.z_stabilizers">
<span class="sig-name descname"><span class="pre">z_stabilizers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.BaconShorCodeLogicalQubit.z_stabilizers" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to set up z stabilizers or ancilla</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubit to set up ancilla for.
Should be either 0 or 1 at present.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.BaconShorCodeLogicalQubit.z_testing">
<span class="sig-name descname"><span class="pre">z_testing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_z_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.BaconShorCodeLogicalQubit.z_testing" title="Permalink to this definition">¶</a></dt>
<dd><p>Introduces one Z error</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubit to test.
Should be either 0 or 1 at present.</p></li>
<li><p><strong>test_z_qubit</strong> (<em>int</em>) – Qubit on which Z error is introduced</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="circuits.SteaneCodeLogicalQubit">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">circuits.</span></span><span class="sig-name descname"><span class="pre">SteaneCodeLogicalQubit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parity_check_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">codewords</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ancilla</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extend_ancilla</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fault_tolerant_b</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fault_tolerant_c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fault_tolerant_ancilla</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ancilla_rounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_rounds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_barrier</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.SteaneCodeLogicalQubit" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">qiskit.circuit.quantumcircuit.QuantumCircuit</span></code></p>
<p>Generates the gates for one or two logical Qubits of the Steane code</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>d</strong> (<em>int</em>) – Number of logical “data” qubits to be initialised.
Should be either 1 or 2 at present.</p></li>
<li><p><strong>parity_check_matrix</strong> (<em>list</em>) – Holds the parity check matrix from which the gates will be constructed.</p></li>
<li><p><strong>codewords</strong> (<em>list</em>) – Valid codewords for the Steane code</p></li>
<li><p><strong>ancilla</strong> (<em>bool</em>) – True if need to set up ancilla.
For some circuits these are not needed.</p></li>
<li><p><strong>extend_ancilla</strong> (<em>bool</em>) – True if need to add extra ancilla for error correction
without using MCT gates</p></li>
<li><p><strong>fault_tolerant_b</strong> (<em>bool</em>) – True if need to set up scheme c for fault tolerant encoding
with three rounds of measurement
on the second logical qubit.</p></li>
<li><p><strong>fault_tolerant_c</strong> (<em>bool</em>) – True if need to set up an extra qubit for fault tolerance</p></li>
<li><p><strong>fault_tolerant_ancilla</strong> (<em>bool</em>) – True if need to set up fault tolerant ancilla</p></li>
<li><p><strong>ancilla_rounds</strong> (<em>int</em>) – Number of rounds of ancilla measurement for
fault tolerant ancilla</p></li>
<li><p><strong>data_round</strong> (<em>int</em>) – Number of rounds of ancilla measurement for
fault tolerant encoding</p></li>
<li><p><strong>self_barrier</strong> (<em>bool</em>) – If true then barriers will be set.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Uses super to inherit methods from parent.
The code is derived from the parity matrix.
The parity matrix is validated to ensure each row
is orthogonal to each valid codeword.
The number of data qubits is calculated from the length
of rows in the parity matrix.
The number of ancilla is calculated from the number
of columns in the parity matrix.
Ancilla qubits are only set up if these are needed.
For error correction without MCT gates these ancilla are extended.
An extra qubit can be added for a fault tolerant logical zero.
Extra measurement ancilla are set up if there is more than one
ancilla measurement round.</p>
<dl class="py method">
<dt class="sig sig-object py" id="circuits.SteaneCodeLogicalQubit.correct_errors">
<span class="sig-name descname"><span class="pre">correct_errors</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mct</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.SteaneCodeLogicalQubit.correct_errors" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces circuit to correct errors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubits on which to correct error.
Should be either 0 or 1 at present.</p></li>
<li><p><strong>mct</strong> (<em>bool</em>) – Controls whether an MCT gate shall be used</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Need to swap ancilla bits to match how printed out.
Reads through Parity matrix to determine the corrections to be applied.</p>
<p>The error correcting circuit is either set up with MCT gates,
which is logically simpler but needs
more gates, or without MCT gates, which is more difficult to
program but needs less gates.
In the latter case the complexity is to take into account corrections
already applied when looking at
two or three bit corrections.</p>
<p>In both cases the error correcting gates are determined from the parity matrix.</p>
<p>The errors detected by the Z operators are bit flips,
so are corrected by CX gates.
The errors detected by the X operators are phase flips, so
are corrected by CZ gates.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.SteaneCodeLogicalQubit.decode">
<span class="sig-name descname"><span class="pre">decode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduced</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simple</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.SteaneCodeLogicalQubit.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Un-computes setting up logical zero for data qubit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubits to set up logical zero for.
Should be either 0 or 1 at present.</p></li>
<li><p><strong>reduced</strong> (<em>bool</em>) – Checks to see if any gates are duplicated</p></li>
<li><p><strong>simple</strong> (<em>bool</em>) – Simple decoding scheme when full logical zero is not required.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Generally this is a reversal of the encoding circuit.
The gates needed are determined from the parity matrix.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.SteaneCodeLogicalQubit.define_data">
<span class="sig-name descname"><span class="pre">define_data</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#circuits.SteaneCodeLogicalQubit.define_data" title="Permalink to this definition">¶</a></dt>
<dd><p>define standing data</p>
<p class="rubric">Notes</p>
<p>The ancilla qubits for the X operator are self.__mx
The ancilla qubits for the Z operator are self.__mz</p>
<p>There are more ancilla qubits if there are fault tolerant ancilla.
In this case the classical measurement bits can support
multiple rounds of measurement.</p>
<p>Also, multiple classical rounds of measurement are supported
for Goto’s schemes b and c.  In scheme b
the multiple classical rounds are only on the second qubit.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.SteaneCodeLogicalQubit.define_registers">
<span class="sig-name descname"><span class="pre">define_registers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">d</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.SteaneCodeLogicalQubit.define_registers" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up registers used based on number of logical qubits
and whether error checking is needed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>d</strong> (<em>int</em>) – Number of logical “data” qubits to be initialised.
Should be either 0 or 1 at present.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The quantum and classical registers are stored in a list so
that they can be indexed by logical qubit
to simplify subsequent code.
The registers needed depend on the number of logical qubits,
whether extra ancilla qubits
are needed for fault tolerance and the number of round of
measurements needed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.SteaneCodeLogicalQubit.dummy_decoding">
<span class="sig-name descname"><span class="pre">dummy_decoding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_string</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.SteaneCodeLogicalQubit.dummy_decoding" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of the full decoding circuit a dummy circuit
is set up for testing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>input_string</strong> (<em>str</em>) – String to control gates set up</p></li>
<li><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubits to apply logical Z gate on.
Should be either 0 or 1 at present.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is not currently used by any workbook but is
retained in case it is useful in future.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.SteaneCodeLogicalQubit.encode_fault_tolerant_method_C">
<span class="sig-name descname"><span class="pre">encode_fault_tolerant_method_C</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">control_qubits</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.SteaneCodeLogicalQubit.encode_fault_tolerant_method_C" title="Permalink to this definition">¶</a></dt>
<dd><p>Use a new qubit to encode fault tolerantly</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubits to encode fault tolerantly.
Should be either 0 or 1 at present.</p></li>
<li><p><strong>control_qubits</strong> (<em>list</em>) – List of control qubits</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Uses Goto’s method C</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.SteaneCodeLogicalQubit.force_X_error">
<span class="sig-name descname"><span class="pre">force_X_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">physical_qubit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.SteaneCodeLogicalQubit.force_X_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Introduce an X error on one physical qubit</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubits to force error on.
Should be either 0 or 1 at present.</p></li>
<li><p><strong>physical_qubit</strong> (<em>int</em>) – Number of qubit to force X error on.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.SteaneCodeLogicalQubit.force_Z_error">
<span class="sig-name descname"><span class="pre">force_Z_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">physical_qubit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.SteaneCodeLogicalQubit.force_Z_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Introduce Z error on one physical qubit</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubits to force error on.
Should be either 0 or 1 at present.</p></li>
<li><p><strong>physical_qubit</strong> (<em>int</em>) – Number of qubit to force Z error on.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.SteaneCodeLogicalQubit.list_data_qubits">
<span class="sig-name descname"><span class="pre">list_data_qubits</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#circuits.SteaneCodeLogicalQubit.list_data_qubits" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a list of data qubits</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>output_list</strong> – list of data qubits</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.SteaneCodeLogicalQubit.logical_data_reset">
<span class="sig-name descname"><span class="pre">logical_data_reset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.SteaneCodeLogicalQubit.logical_data_reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the data for a logical qubit</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubits to reset.
Should be either 0 or 1 at present.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is needed for a fault tolerant encoding scheme.
Usually the data qubits are reset as part of setting up the logical zero.
In one scheme the logical zero is not set up, but a reset
is still needed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.SteaneCodeLogicalQubit.logical_gate_CX">
<span class="sig-name descname"><span class="pre">logical_gate_CX</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logical_control_qubit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logical_target_qubit</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.SteaneCodeLogicalQubit.logical_gate_CX" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a logical CX gate</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>logical_control_qubit</strong> (<em>int</em>) – Number of the logical “data” qubit
which controls the CX gate</p></li>
<li><p><strong>logical_target_qubit</strong> (<em>int</em>) – Number of the logical “data” qubit
which is the target for the CX gate</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.SteaneCodeLogicalQubit.logical_gate_H">
<span class="sig-name descname"><span class="pre">logical_gate_H</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.SteaneCodeLogicalQubit.logical_gate_H" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a logical H gate</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubits to apply Hadamard on.
Should be either 0 or 1 at present.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.SteaneCodeLogicalQubit.logical_gate_X">
<span class="sig-name descname"><span class="pre">logical_gate_X</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.SteaneCodeLogicalQubit.logical_gate_X" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a logical X gate</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubits to apply logical X gate to.
Should be either 0 or 1 at present.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.SteaneCodeLogicalQubit.logical_gate_Z">
<span class="sig-name descname"><span class="pre">logical_gate_Z</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.SteaneCodeLogicalQubit.logical_gate_Z" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply a logical Z gate</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubits to apply logical Z gate on.
Should be either 0 or 1 at present.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.SteaneCodeLogicalQubit.logical_measure_ancilla">
<span class="sig-name descname"><span class="pre">logical_measure_ancilla</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ancilla_round</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.SteaneCodeLogicalQubit.logical_measure_ancilla" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes measurement of the ancilla qubits of a logical qubit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubits to measure.
Should be either 0 or 1 at present.</p></li>
<li><p><strong>ancilla_round</strong> (<em>int</em>) – Round of ancilla measurement.
Can be more than one for fault tolerant ancilla.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If there is more than one ancilla round of measurement the classical
measurements bit created above can be used.
For example, if there are three rounds of measuremement
three classical measurement bits are created,
one for each round.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.SteaneCodeLogicalQubit.logical_measure_data">
<span class="sig-name descname"><span class="pre">logical_measure_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.SteaneCodeLogicalQubit.logical_measure_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes measurement of the data qubits of a logical qubit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubits to measure.
Should be either 0 or 1 at present.</p></li>
<li><p><strong>measure_round</strong> (<em>int</em>) – Round of data measurement.
Can be more than one for scheme B or C.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For Scheme B there are normally three rounds of measuremement for the
second logical qubit and three classical measurement bits are created,
one for each round.  For Scheme C there are also normally three rounds
of measurement.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.SteaneCodeLogicalQubit.logical_measure_data_FT">
<span class="sig-name descname"><span class="pre">logical_measure_data_FT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">measure_round</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.SteaneCodeLogicalQubit.logical_measure_data_FT" title="Permalink to this definition">¶</a></dt>
<dd><p>Makes measurement of the data qubits of a logical qubit needed for FT schemes</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubits to measure.
Should be either 0 or 1 at present.</p></li>
<li><p><strong>measure_round</strong> (<em>int</em>) – Round of data measurement.  Can be more than one for scheme B or C.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>For Scheme B there are normally three rounds of measuremement for the second
logical qubit and three classical measurement bits are created,
one for each round.
For Scheme C there are also normally three rounds of measurement.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.SteaneCodeLogicalQubit.set_up_ancilla">
<span class="sig-name descname"><span class="pre">set_up_ancilla</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.SteaneCodeLogicalQubit.set_up_ancilla" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up gates for ancilla based on entries in the parity matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubits to set up ancilla gates for.
Should be either 0 or 1 at present.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The ancilla needed are determined from the parity matrix.
Fault tolerant logic sets up four
ancilla qubits, set these up in a GHZ, and then
apply a CZ gate to each one individually and then
decomputes the GHZ gate.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.SteaneCodeLogicalQubit.set_up_logical_zero">
<span class="sig-name descname"><span class="pre">set_up_logical_zero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">logical_qubit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reduced</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">logical_one</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#circuits.SteaneCodeLogicalQubit.set_up_logical_zero" title="Permalink to this definition">¶</a></dt>
<dd><p>Set up logical zero for data qubit</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>logical_qubit</strong> (<em>int</em>) – Number of the logical “data” qubit to initialise.
Should be either 0 or 1 at present.</p></li>
<li><p><strong>reduced</strong> (<em>bool</em>) – Checks to see if any gates are duplicated</p></li>
<li><p><strong>logical_one</strong> (<em>bool</em>) – Add extra gates to set up a logical one</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Columns of the parity matrix with only one entry are
prepared in the + state.
CX gates from these + state to the parity matrix entries
in the same row which are unity.</p>
<p>If reduced = True possible unnecessary
duplicate CX gates are identified.
If possible two CX gates are removed and
replaced by one new CX gates.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="circuits.SteaneCodeLogicalQubit.validate_parity_matrix">
<span class="sig-name descname"><span class="pre">validate_parity_matrix</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#circuits.SteaneCodeLogicalQubit.validate_parity_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Validate the parity matrix against the allowed codewords</p>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="test_circuits.html" class="btn btn-neutral float-right" title="test_circuits module" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="modules.html" class="btn btn-neutral float-left" title="Python modules" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2021, Daniel Goldsmith.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>